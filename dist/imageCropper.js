// Generated by CoffeeScript 1.10.0
(function() {
  var ImageCropper;

  ImageCropper = (function() {
    function ImageCropper(options) {
      this.inputId = options.input;
      this.containerId = options.container;
      this.containerWidth = options.containerWidth;
      this.containerHeight = options.containerHeight || 240;
      this.widthAdapt = options.widthAdapt || false;
      this.heightAdapt = options.heightAdapt || false;
      this.cropperWidth = options.cropperWidth || 0;
      this.cropperRatio = options.ratio || 1;
      this.croppedWidth = options.resultWidth || this.cropperWidth;
      this.cropperRound = options.round || false;
      this.hd = options.hd || false;
      this.cropCallback = options.crop || null;
      this.onError = options.onError || null;
      this.fileSizeLimit = options.fileSizeLimit || Infinity;
      this.input = options.input || document.querySelector(this.inputId);
      this.container = options.container || document.querySelector(this.containerId);
      this.imageContainer = document.createElement('div');
      this.imageContainer.style.position = 'relative';
      this.imageContainer.style.top = '0px';
      this.imageContainer.style.left = '0px';
      this.imageContainer.style.overflow = 'hidden';
      this.imageContainer.style.width = this.containerWidth + "px";
      this.imageContainer.style.height = this.containerHeight + "px";
      this._events = {};
      this.sourceImage = document.createElement('canvas');
      this.cropper = document.createElement('canvas');
      this.cropperSeResize = document.createElement('canvas');
      this.cropperSource = document.createElement('canvas');
      this.imageOpti = document.createElement('canvas');
      this.image = new Image();
      this.imageRatio = 1;
      this.reader = new FileReader();
      this.cropperSeResizeSize = 10;
      this.cropperOffsetTop = 0;
      this.cropperOffsetLeft = 0;
      this.imageOffsetTop = 0;
      this.imageOffsetLeft = 0;
      this.cropperPrevX = 0;
      this.cropperPrevY = 0;
      this.imagePrevX = 0;
      this.imagePrevY = 0;
      this.cropperResizePrevX = 0;
      this.cropperResizePrevY = 0;
      this.listenTo(this.input, 'change', this.readFile);
      this.listenTo(this.reader, 'load', this.fileReady);
      this.listenTo(this.image, 'load', this.imageReady);
      this.listenTo(this.sourceImage, 'mousedown', this.sourceImageMousedown);
      this.listenTo(this.sourceImage, 'touchstart', this.sourceImageMousedown);
      this.listenTo(this.cropper, 'mousedown', this.cropperMousedown);
      this.listenTo(this.cropper, 'touchstart', this.cropperMousedown);
      this.listenTo(this.cropperSeResize, 'mousedown', this.cropperSeResizeMousedown);
      this.listenTo(this.cropperSeResize, 'touchstart', this.cropperSeResizeMousedown);
      this.listenTo(document, 'mouseup', this.stopListeningMousemove);
      this.listenTo(document, 'touchend', this.stopListeningMousemove);
      this.container.innerHTML = '';
      this.container.appendChild(this.imageContainer);
      if (options.file) {
        if (options.file.size > this.fileSizeLimit) {
          if (typeof this.onError === "function") {
            this.onError('sizeTooLarge');
          }
          return;
        }
        this.reader.readAsDataURL(options.file);
      }
    }

    ImageCropper.prototype.stopListeningMousemove = function() {
      this.stopListening(document, 'mousemove');
      this.stopListening(document, 'touchmove');
      return this.cropperListener();
    };

    ImageCropper.prototype.listenTo = function(ele, eventName, eventListener) {
      var base;
      (base = this._events)[eventName] || (base[eventName] = []);
      eventListener = eventListener.bind(this);
      this._events[eventName].push({
        ele: ele,
        eventListener: eventListener
      });
      return ele.addEventListener(eventName, eventListener, false);
    };

    ImageCropper.prototype.stopListening = function(ele, eventName) {
      var data, events, item, j, k, len, len1, ref, results;
      if (!ele) {
        ref = this._events;
        for (eventName in ref) {
          events = ref[eventName];
          for (j = 0, len = events.length; j < len; j++) {
            item = events[j];
            item.ele.removeEventListener(eventName, item.eventListener, false);
          }
        }
        return this._events = {};
      } else {
        data = this._events[eventName] || [];
        this._events[eventName] = [];
        results = [];
        for (k = 0, len1 = data.length; k < len1; k++) {
          item = data[k];
          if (item.ele === ele) {
            results.push(ele.removeEventListener(eventName, item.eventListener, false));
          } else {
            results.push(this._events[eventName].push(item));
          }
        }
        return results;
      }
    };

    ImageCropper.prototype.readFile = function(e) {
      var file;
      file = e.target.files[0];
      if (file) {
        if (file.size > this.fileSizeLimit) {
          if (typeof this.onError === "function") {
            this.onError('sizeTooLarge');
          }
          return;
        }
        return this.reader.readAsDataURL(e.target.files[0]);
      }
    };

    ImageCropper.prototype.fileReady = function(e) {
      return this.image.src = e.target.result;
    };

    ImageCropper.prototype.imageReady = function() {
      var cropperBaseHeight, cropperBaseWidth, cropperSeResizeCtx, heightAdapt, sourceImageCtx, widthAdapt;
      this.sourceImage.width = this.image.width;
      this.sourceImage.height = this.image.height;
      sourceImageCtx = this.sourceImage.getContext('2d');
      sourceImageCtx.fillStyle = 'white';
      sourceImageCtx.fillRect(0, 0, this.image.width, this.image.height);
      sourceImageCtx.drawImage(this.image, 0, 0);
      sourceImageCtx.fillStyle = 'rgba(0, 0, 0, 0.5)';
      sourceImageCtx.fillRect(0, 0, this.image.width, this.image.height);
      this.sourceImage.style.cursor = 'move';
      this.sourceImage.style.position = 'absolute';
      this.sourceImage.style.top = '0px';
      this.sourceImage.style.left = '0px';
      this.imageContainer.appendChild(this.sourceImage);
      if (this.image.width > 1200 && this.image.height > 1200) {
        this.imageOptiRatio = Math.max(this.image.width, this.image.height) / 1200;
      } else {
        this.imageOptiRatio = 1;
      }
      this.imageOpti.width = ~~(this.image.width / this.imageOptiRatio);
      this.imageOpti.height = ~~(this.image.height / this.imageOptiRatio);
      this.imageOpti.getContext('2d').drawImage(this.image, 0, 0, this.imageOpti.width, this.imageOpti.height);
      widthAdapt = (function(_this) {
        return function() {
          var sourceImageHeight;
          _this.sourceImage.style.width = _this.containerWidth + "px";
          _this.sourceImageWidth = _this.containerWidth;
          sourceImageHeight = _this.image.height * _this.containerWidth / _this.image.width;
          _this.sourceImage.style.height = sourceImageHeight + "px";
          _this.sourceImageLeft = 0;
          _this.sourceImageTop = (_this.containerHeight - sourceImageHeight) / 2;
          return _this.sourceImage.style.top = _this.sourceImageTop + "px";
        };
      })(this);
      heightAdapt = (function(_this) {
        return function() {
          _this.sourceImage.style.height = _this.containerHeight + "px";
          _this.sourceImageWidth = _this.image.width * _this.containerHeight / _this.image.height;
          _this.sourceImage.style.width = _this.sourceImageWidth + "px";
          _this.sourceImageLeft = (_this.containerWidth - _this.sourceImageWidth) / 2;
          _this.sourceImageTop = 0;
          return _this.sourceImage.style.left = _this.sourceImageLeft + "px";
        };
      })(this);
      if (this.widthAdapt && !this.heightAdapt) {
        widthAdapt();
      } else if (this.heightAdapt && !this.widthAdapt) {
        heightAdapt();
      } else if (this.widthAdapt && this.heightAdapt) {
        this.sourceImage.style.cursor = 'default';
        if (this.image.width / this.image.height >= this.containerWidth / this.containerHeight) {
          widthAdapt();
        } else {
          heightAdapt();
        }
      } else {
        if (this.image.width / this.image.height >= this.containerWidth / this.containerHeight) {
          heightAdapt();
        } else {
          widthAdapt();
        }
      }
      this.imageStyleWidth = parseInt(this.sourceImage.style.width.slice(0, -2));
      this.imageStyleHeight = parseInt(this.sourceImage.style.height.slice(0, -2));
      cropperBaseWidth = this.imageStyleWidth;
      if (this.imageStyleWidth > this.containerWidth) {
        cropperBaseWidth = this.containerWidth;
      }
      cropperBaseHeight = this.imageStyleHeight;
      if (this.imageStyleHeight > this.containerHeight) {
        cropperBaseHeight = this.containerHeight;
      }
      this.imageRatio = this.sourceImageWidth / this.sourceImage.width;
      this.imageOffsetTop = this.sourceImageTop / this.imageRatio;
      this.imageOffsetLeft = this.sourceImageLeft / this.imageRatio;
      if (this.cropperWidth === 0 || this.cropperWidth > this.sourceImageWidth) {
        this.cropperWidth = this.sourceImageWidth * 0.8;
      }
      this.cropperHeight = this.cropperWidth / this.cropperRatio;
      if (this.cropperRatio > cropperBaseWidth / cropperBaseHeight) {
        if (this.cropperWidth > cropperBaseWidth) {
          this.cropperWidth = this.cropperBaseWidth * 0.8;
          this.cropperHeight = this.cropperWidth / this.cropperRatio;
        }
      } else {
        if (this.cropperHeight > cropperBaseHeight) {
          this.cropperHeight = cropperBaseHeight * 0.8;
          this.cropperWidth = this.cropperHeight * this.cropperRatio;
        }
      }
      this.cropperOffsetTop = (this.containerHeight - this.cropperHeight) / 2;
      this.cropperOffsetLeft = (this.containerWidth - this.cropperWidth) / 2;
      this.cropper.style.cursor = 'move';
      this.cropper.style.position = 'absolute';
      this.imageContainer.appendChild(this.cropper);
      this.cropperSeResize.width = this.cropperSeResize.height = this.cropperSeResizeSize;
      cropperSeResizeCtx = this.cropperSeResize.getContext('2d');
      cropperSeResizeCtx.fillStyle = 'rgba(0, 0, 0, 0.24)';
      cropperSeResizeCtx.fillRect(0, 0, this.cropperSeResizeSize, this.cropperSeResizeSize);
      cropperSeResizeCtx.beginPath();
      cropperSeResizeCtx.moveTo(0, 0);
      cropperSeResizeCtx.lineTo(this.cropperSeResizeSize, 0);
      cropperSeResizeCtx.lineTo(this.cropperSeResizeSize, this.cropperSeResizeSize);
      cropperSeResizeCtx.lineTo(0, this.cropperSeResizeSize);
      cropperSeResizeCtx.closePath();
      cropperSeResizeCtx.lineWidth = 2;
      cropperSeResizeCtx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
      cropperSeResizeCtx.stroke();
      this.cropperSeResize.style.cursor = 'se-resize';
      this.cropperSeResize.style.position = 'absolute';
      this.imageContainer.appendChild(this.cropperSeResize);
      return this.cropperListener();
    };

    ImageCropper.prototype.cropperListener = function(hd) {
      var cropperBorder, cropperBuffer, cropperBufferCtx, cropperCtx, cropperSourceCtx, drawHeight, drawWidth, height, imageSrc, metaOffset, radius, sheight, swidth, sx, sy, width;
      if (hd == null) {
        hd = true;
      }
      this.cropperWidth = ~~this.cropperWidth;
      this.cropperHeight = ~~this.cropperHeight;
      sx = -this.imageOffsetLeft + (this.cropperOffsetLeft - parseFloat(this.imageContainer.style.left.slice(0, -2))) / this.imageRatio;
      sy = -this.imageOffsetTop + (this.cropperOffsetTop - parseFloat(this.imageContainer.style.top.slice(0, -2))) / this.imageRatio;
      swidth = this.cropperWidth / this.imageRatio;
      if (!(sx + swidth <= this.image.width)) {
        swidth = this.image.width - sx;
      }
      sheight = this.cropperHeight / this.imageRatio;
      if (!(sy + sheight <= this.image.height)) {
        sheight = this.image.height - sy;
      }
      width = swidth;
      height = sheight;
      imageSrc = this.image;
      if (!hd) {
        sx = ~~(sx / this.imageOptiRatio);
        sy = ~~(sy / this.imageOptiRatio);
        swidth = ~~(swidth / this.imageOptiRatio);
        sheight = ~~(sheight / this.imageOptiRatio);
        width = this.cropperWidth;
        height = this.cropperHeight;
        imageSrc = this.imageOpti;
      }
      this.cropper.width = width;
      this.cropper.height = height;
      cropperCtx = this.cropper.getContext('2d');
      cropperCtx.drawImage(imageSrc, sx, sy, swidth, sheight, 0, 0, width, height);
      cropperBorder = 1;
      cropperCtx.save();
      this.cropperSource.width = width;
      this.cropperSource.height = height;
      cropperSourceCtx = this.cropperSource.getContext('2d');
      cropperSourceCtx.fillStyle = 'white';
      cropperSourceCtx.fillRect(0, 0, width, height);
      cropperSourceCtx.drawImage(imageSrc, sx, sy, swidth, sheight, 0, 0, width, height);
      if (this.cropperRound) {
        cropperCtx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        cropperCtx.fillRect(0, 0, width, height);
        cropperBuffer = document.createElement('canvas');
        cropperBuffer.width = width;
        cropperBuffer.height = height;
        cropperBufferCtx = cropperBuffer.getContext('2d');
        cropperBufferCtx.drawImage(this.cropperSource, 0, 0);
        cropperBufferCtx.globalCompositeOperation = 'destination-in';
        if (width > height) {
          radius = height;
        } else {
          radius = width;
        }
        radius = radius / 2;
        radius = radius >= 0 ? radius : 0;
        cropperBufferCtx.arc(width / 2, height / 2, radius, 0, Math.PI * 2);
        cropperBufferCtx.fill();
        cropperCtx.drawImage(cropperBuffer, 0, 0);
      }
      cropperCtx.restore();
      cropperCtx.beginPath();
      cropperBorder = Math.ceil(cropperBorder * width / this.cropperWidth);
      metaOffset = cropperBorder / 2;
      drawWidth = ~~width;
      drawHeight = ~~height;
      cropperCtx.moveTo(metaOffset, metaOffset);
      cropperCtx.lineTo(drawWidth - metaOffset, metaOffset);
      cropperCtx.lineTo(drawWidth - metaOffset, drawHeight - metaOffset);
      cropperCtx.lineTo(metaOffset, drawHeight - metaOffset);
      cropperCtx.closePath();
      cropperCtx.lineWidth = cropperBorder;
      cropperCtx.strokeStyle = 'rgba(255, 255, 255, 0.24)';
      cropperCtx.stroke();
      if (typeof this.cropCallback === "function") {
        this.cropCallback(this.cropperSource);
      }
      this.cropper.style.top = this.cropperOffsetTop + "px";
      this.cropper.style.left = this.cropperOffsetLeft + "px";
      this.cropper.style.width = this.cropperWidth + "px";
      this.cropper.style.height = this.cropperHeight + "px";
      this.cropperSeResize.style.top = this.cropperOffsetTop + this.cropperHeight - this.cropperSeResizeSize / 2 + 'px';
      return this.cropperSeResize.style.left = this.cropperOffsetLeft + this.cropperWidth - this.cropperSeResizeSize / 2 + 'px';
    };

    ImageCropper.prototype.sourceImageMousedown = function(e) {
      e.preventDefault();
      this.imagePrevX = e.clientX || e.targetTouches[0].clientX;
      this.imagePrevY = e.clientY || e.targetTouches[0].clientY;
      this.listenTo(document, 'mousemove', this.sourceImageMove);
      return this.listenTo(document, 'touchmove', this.sourceImageMove);
    };

    ImageCropper.prototype.sourceImageMove = function(e) {
      var clientX, clientY, offsetLeft, offsetLeftLimit, offsetTop, offsetTopLimit;
      e.preventDefault();
      if (this.sourceImage.offsetWidth > this.containerWidth) {
        clientX = e.clientX || e.targetTouches[0].clientX;
        offsetLeft = clientX - this.imagePrevX + parseFloat(this.sourceImage.style.left.slice(0, -2));
        offsetLeftLimit = this.containerWidth - this.sourceImage.offsetWidth;
        if (offsetLeft < offsetLeftLimit) {
          offsetLeft = offsetLeftLimit;
        }
        if (offsetLeft > 0) {
          offsetLeft = 0;
        }
        if (this.sourceImage.offsetWidth > this.containerWidth) {
          this.sourceImage.style.left = offsetLeft + "px";
        }
      } else {
        clientY = e.clientY || e.targetTouches[0].clientY;
        offsetTop = clientY - this.imagePrevY + parseFloat(this.sourceImage.style.top.slice(0, -2));
        offsetTopLimit = this.containerHeight - this.sourceImage.offsetHeight;
        if (offsetTop < offsetTopLimit) {
          offsetTop = offsetTopLimit;
        }
        if (offsetTop > 0) {
          offsetTop = 0;
        }
        if (this.sourceImage.offsetHeight > this.containerHeight) {
          this.sourceImage.style.top = offsetTop + "px";
        }
      }
      this.imagePrevX = e.clientX || e.targetTouches[0].clientX;
      this.imagePrevY = e.clientY || e.targetTouches[0].clientY;
      this.imageOffsetTop = parseFloat(this.sourceImage.style.top.slice(0, -2)) / this.imageRatio;
      this.imageOffsetLeft = parseFloat(this.sourceImage.style.left.slice(0, -2)) / this.imageRatio;
      return this.cropperListener(this.hd);
    };

    ImageCropper.prototype.cropperMousedown = function(e) {
      e.preventDefault();
      this.cropperPrevX = e.clientX || e.targetTouches[0].clientX;
      this.cropperPrevY = e.clientY || e.targetTouches[0].clientY;
      this.listenTo(document, 'mousemove', this.cropperMove);
      return this.listenTo(document, 'touchmove', this.cropperMove);
    };

    ImageCropper.prototype.cropperMove = function(e) {
      var clientX, clientY, cropperLeftMax, cropperLeftMin, cropperTopMax, cropperTopMin;
      e.preventDefault();
      clientX = e.clientX || e.targetTouches[0].clientX;
      clientY = e.clientY || e.targetTouches[0].clientY;
      this.cropperOffsetTop = clientY - this.cropperPrevY + this.cropper.offsetTop;
      this.cropperOffsetLeft = clientX - this.cropperPrevX + this.cropper.offsetLeft;
      if (this.imageStyleHeight < this.containerHeight) {
        cropperTopMin = (this.containerHeight - this.imageStyleHeight) / 2;
        cropperTopMax = cropperTopMin + this.imageStyleHeight - this.cropperHeight;
      } else {
        cropperTopMax = this.containerHeight - this.cropperHeight;
        cropperTopMin = 0;
      }
      if (this.cropperOffsetTop > cropperTopMax) {
        this.cropperOffsetTop = cropperTopMax;
      }
      if (this.cropperOffsetTop < cropperTopMin) {
        this.cropperOffsetTop = cropperTopMin;
      }
      if (this.imageStyleWidth < this.containerWidth) {
        cropperLeftMin = (this.containerWidth - this.imageStyleWidth) / 2;
        cropperLeftMax = cropperLeftMin + this.imageStyleWidth - this.cropperWidth;
      } else {
        cropperLeftMax = this.containerWidth - this.cropperWidth;
        cropperLeftMin = 0;
      }
      if (this.cropperOffsetLeft > cropperLeftMax) {
        this.cropperOffsetLeft = cropperLeftMax;
      }
      if (this.cropperOffsetLeft < cropperLeftMin) {
        this.cropperOffsetLeft = cropperLeftMin;
      }
      this.cropperPrevX = e.clientX || e.targetTouches[0].clientX;
      this.cropperPrevY = e.clientY || e.targetTouches[0].clientY;
      return this.cropperListener(this.hd);
    };

    ImageCropper.prototype.cropperSeResizeMousedown = function(e) {
      e.preventDefault();
      this.cropperResizePrevX = e.clientX || e.targetTouches[0].clientX;
      this.cropperResizePrevY = e.clientY || e.targetTouches[0].clientY;
      this.listenTo(document, 'mousemove', this.cropperSeResizeMove);
      return this.listenTo(document, 'touchmove', this.cropperSeResizeMove);
    };

    ImageCropper.prototype.cropperSeResizeMove = function(e) {
      var clientX, clientY, heightLimit, widthLimit;
      e.preventDefault();
      if (this.imageStyleWidth < this.containerWidth) {
        widthLimit = this.imageStyleWidth / 2 + this.containerWidth / 2 - this.cropperOffsetLeft;
      } else {
        widthLimit = this.containerWidth - this.cropperOffsetLeft;
      }
      if (this.imageStyleHeight < this.containerHeight) {
        heightLimit = this.imageStyleHeight / 2 + this.containerHeight / 2 - this.cropperOffsetTop;
      } else {
        heightLimit = this.containerHeight - this.cropperOffsetTop;
      }
      if (this.cropperRatio >= 1) {
        clientX = e.clientX || e.targetTouches[0].clientX;
        this.cropperWidth += clientX - this.cropperResizePrevX;
        if (this.cropperWidth < 0) {
          this.cropperWidth = 0;
        }
        if (this.cropperWidth > widthLimit) {
          this.cropperWidth = widthLimit;
        }
        this.cropperHeight = Math.floor(this.cropperWidth / this.cropperRatio);
        if (this.cropperHeight > heightLimit) {
          this.cropperHeight = heightLimit;
          this.cropperWidth = this.cropperHeight * this.cropperRatio;
        }
      } else {
        clientY = e.clientY || e.targetTouches[0].clientY;
        this.cropperHeight += clientY - this.cropperResizePrevY;
        if (this.cropperHeight < 0) {
          this.cropperHeight = 0;
        }
        if (this.cropperHeight > heightLimit) {
          this.cropperHeight = heightLimit;
        }
        this.cropperWidth = Math.floor(this.cropperHeight * this.cropperRatio);
        if (this.cropperWidth > widthLimit) {
          this.cropperWidth = widthLimit;
          this.cropperHeight = this.cropperWidth / this.cropperRatio;
        }
      }
      if (this.cropperWidth < 10) {
        this.cropperWidth = 10;
        this.cropperHeight = this.cropperWidth / this.cropperRatio;
      }
      this.cropperResizePrevX = e.clientX || e.targetTouches[0].clientX;
      this.cropperResizePrevY = e.clientY || e.targetTouches[0].clientY;
      return this.cropperListener(this.hd);
    };

    ImageCropper.prototype.toBlob = function() {
      var croppedCanvas, data, dataArray, dataLength, dataMIME, dataStr, dataURL, i, j, len, uint8Data;
      croppedCanvas = document.createElement('canvas');
      croppedCanvas.width = this.croppedWidth;
      croppedCanvas.height = this.croppedWidth / this.cropperRatio;
      croppedCanvas.getContext('2d').drawImage(this.cropperSource, 0, 0, croppedCanvas.width, croppedCanvas.height);
      dataMIME = 'image/png';
      dataURL = croppedCanvas.toDataURL(dataMIME);
      dataArray = dataURL.split(',');
      dataStr = window.atob(dataArray[1]);
      dataLength = dataStr.length;
      uint8Data = new Uint8Array(dataLength);
      for (i = j = 0, len = dataStr.length; j < len; i = ++j) {
        data = dataStr[i];
        uint8Data[i] = data.charCodeAt(0);
      }
      return new Blob([uint8Data], {
        type: dataMIME
      });
    };

    ImageCropper.prototype.toDataURL = function() {
      return this.cropperSource.toDataURL();
    };

    ImageCropper.prototype.destroy = function() {
      return this.stopListening();
    };

    return ImageCropper;

  })();

}).call(this);
